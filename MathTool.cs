using System;
using UnityEngine;
using UnityPlugins.Extension;

namespace UnityPlugins {
    /// <summary>
    ///     A class that contains mathematical tools.
    /// </summary>
    public static class MathTool {
        /// <summary>
        ///     Checks if both <see cref="Vector2" />s are in a diagonal position.
        /// </summary>
        /// <param name="position1">The first position.</param>
        /// <param name="position2">The second position.</param>
        /// <returns>
        ///     Returns true if diagonal. <br />
        ///     Otherwise, false.
        /// </returns>
        public static bool IsDiagonal(Vector2 position1, Vector2 position2) => ((position1.x != position2.x) && (position1.y != position2.y));

        /// <summary>
        ///     Clamps a value.
        /// </summary>
        /// <param name="value">A value to clamp.</param>
        /// <param name="min">The minimum value.</param>
        /// <param name="max">The maximum value.</param>
        /// <typeparam name="T">The type of the value to clamp.</typeparam>
        /// <returns>Returns a clamped value.</returns>
        public static T Clamp<T>(T value,
                                 T min,
                                 T max) where T : IComparable {
            if (value.IsSmallerThan(min) == true) {
                value = min;
            } else if (value.IsGreaterThan(max) == true) {
                value = max;
            }
            return value;
        }

        private static System.Random random = new System.Random(Guid.NewGuid()
                                                                    .GetHashCode());

        /// <summary>
        ///     Uses <see cref="System.Random" /> with a seed generated by <see cref="Guid.NewGuid()" />.<see cref="Guid.GetHashCode()" />.
        /// </summary>
        /// <param name="seed">An optional seed parameter.</param>
        /// <typeparam name="T">An enum type to randomly select from.</typeparam>
        /// <returns>Returns a random enum value.</returns>
        public static T RandomEnum<T>(int? seed = null) where T : Enum {
            if (seed != null) {
                random = new System.Random((int)(seed));
            }
            Array values = Enum.GetValues(typeof(T));
            return (T)(values.GetValue(random.Next(values.Length)));
        }

        /// <summary>
        ///     Uses <see cref="System.Random" /> with a seed generated by <see cref="Guid.NewGuid()" />.<see cref="Guid.GetHashCode()" />.
        /// </summary>
        /// <param name="start">Inclusive start.</param>
        /// <param name="end">Exclusive end.</param>
        /// <param name="seed">An optional seed parameter.</param>
        /// <typeparam name="T">An enum type to randomly select from.</typeparam>
        /// <returns>
        ///     Returns a random enum value from a range from inclusive <paramref name="start" /> to exclusive <paramref name="end" />.
        /// </returns>
        public static T RandomEnum<T>(int start,
                                      int end,
                                      int? seed = null) where T : Enum {
            if (seed != null) {
                random = new System.Random((int)(seed));
            }
            Array values = Enum.GetValues(typeof(T));
            return (T)(values.GetValue(random.Next(start, end)));
        }

        /// <summary>
        ///     Calculates <see cref="Vector2" /> direction.
        /// </summary>
        /// <param name="position1">Starting position.</param>
        /// <param name="position2">Ending position.</param>
        /// <returns>Returns direction relative to <paramref name="position1" />.</returns>
        public static Vector2 CalculateDirection(Vector2 position1, Vector2 position2) {
            Vector2 subtracted = (position1 - position2),
                    direction = Vector2.zero;
            if (subtracted.x > 0f) {
                direction.x = -1f;
            } else if (subtracted.x != 0f) {
                direction.x = 1f;
            }

            if (subtracted.y > 0f) {
                direction.y = -1f;
            } else if (subtracted.y != 0f) {
                direction.y = 1f;
            }

            return direction;
        }

        /// <summary>
        ///     Calculates <see cref="Vector3" /> direction.
        /// </summary>
        /// <param name="position1">Starting position.</param>
        /// <param name="position2">Ending position.</param>
        /// <returns>Returns distance relative to <paramref name="position1" />.</returns>
        public static Vector3 CalculateDirection(Vector3 position1, Vector3 position2) {
            Vector3 subtracted = (position1 - position2),
                    direction = Vector3.zero;
            if (subtracted.x > 0f) {
                direction.x = -1f;
            } else if (subtracted.x != 0f) {
                direction.x = 1f;
            }

            if (subtracted.y > 0f) {
                direction.y = -1f;
            } else if (subtracted.y != 0f) {
                direction.y = 1f;
            }

            if (subtracted.z > 0f) {
                direction.z = -1f;
            } else if (subtracted.z != 0f) {
                direction.z = 1f;
            }

            return direction;
        }
    }
}